LeetCode

1. 两数之和: 

   ```
   使用HashMap降低时间复杂度，只做一次循环。
   ```

2. 两数相加

   ```
   链表的反转，需要用到三个指针 pre cur next
   本位和和进位的处理
   ```

3. 无重复字符的最长字串

   ```
   使用滑动窗口，滑动窗口相当于一个队列，将满足的元素入队，将不满足的元素出队。不满足的元素想要出队需要将该元素之前的全都先出队。
   滑动窗口需要用到两个指针，用来窗口的头和尾
   ```

4. 寻找两个正序数组的中位数

   ```
   笨办法：开辟一个可以容纳这两个数组的新数组，将元素按照正序放入，奇数取 num[length / 2],偶数则取 (num[(length/2)-1] +num[length / 2]) / 2
   目前还没研究明白聪明的做法
   ```

5. 最长回文字串

   ```
   笨办法：列出所有的子串，判断是否为回文，记录最长的回文串长度
   新办法：使用中心扩散法，要判断回文长度为奇数还是偶数这两种情况，为奇数则 i = index-1， j = index+1; 为偶数则i=index，j=index+1。index为判断中心。
   ```

6.  N字型变换

   ```
   找规律即可， 例如 numRows 为4的话，则原来字符串中每个字符所对在的行数就为 1234321234，变换过后第一行的元素则是行数为1的所有元素
   ```

7. 反转int整数

   ```
   题目条件要求不能用long，所以要判断溢出需要特殊处理。
   if (num > 214748364 || num == 214748364 && num[i] > 7)
   ```

8. 字符串转换成整数

   ```
   去掉空格 -> 判断正负号 -> 读取数字 -> 遇到非数字或者字符串结尾则结束
   多读几遍题，多测边界值
   ```


10. 正则表达式匹配

    ```
    
    ```

11. 盛最多水的容器

    ```
    方法一：暴力循环，时间复杂度 O(n^2)
    方法二：双指针，i和j分别指向首元素和尾元素，当底的长度确定时，容量的大小只跟最短的高有关。所以判断height[i]和height[j]的大小，那边小则挪动那边的指针。
    ```

    

